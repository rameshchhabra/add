<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Generate some random number combination of two digit and tree digit and
      store the sumation and print on click on the button
    </title>
    <style>
      * {
        margin: 0%;
        padding: 0%;
      }
      .container {
        background-color: bisque;
        margin: auto;
        width: 70vw;
        height: 70vh;
      }
      #head {
        text-align: center;
        size: 20px;
        text-transform: uppercase;
        margin: 50px auto 50px auto;
      }
      span {
        color: rgb(39, 48, 45);
        margin: 10px;
        /* size: 50px; */
        font-size: larger;
      }
      .num,
      .but {
        display: flex;
        justify-content: center;
      }
      p {
        padding: 2px;
        margin: 50px auto 20px auto;
        text-align: center;
      }
      #button,
      #next {
        margin: auto 10px auto 10px;
        width: 100px;
        height: 25px;
        background-color: cadetblue;
        border-radius: 10%;
        cursor: pointer;
      }
      #button:hover,
      #next:hover {
        background-color: azure;
      }
        @media screen and (max-width: 50em) {
        .container {
          background-color: bisque;
          margin: auto;
          width: 90vw;
          height: 90vh;
        }
        #button,
        #next {
          margin: 200px 10px auto 10px;
          /* width: 100px; */
          /* height: 25px; */
          /* background-color: cadetblue; */
          /* border-radius: 10%; */
          /* cursor: pointer; */
        }
        body {
          background-color: aquamarine;
        }
      }
    </style>
  </head>
  <body>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <div class="container">
      <h2 id="head">addition Practice game</h2>
      <div class="num">
        <p>
          use your mind <br />
          press next to start the game
        </p>
      </div>
      <p>.........</p>
      <br />
      <div class="but">
        <button id="button" type="submit">Result</button>
        <button id="next" type="submit">next</button>
      </div>
    </div>
    <script>
      // var size = Math.floor(Math.random() * (10 - 2) + 2);
      // console.log(size);
      //random number are generated from 2 to 10

      //append the number of span tags according to the size of the array
      // var size;
      // var ar = [];
      function create_size() {
        var size = Math.floor(Math.random() * (10 - 2) + 2);
        return size;
        // console.log(size);
      }

      //logic for append the span according to the size of the generated size of array

      function ape(size) {
        for (let a = 0; a < size; a++) {
          var s = document.querySelector(".num").appendChild(createee(ar[a]));
        }
      }

      function createee(data) {
        let spla = document.createElement("span");
        spla.textContent = data;
        return spla;
      }

      //creating the elements in the array

      function createlevel1(size) {
        for (var i = 0; i < size; i++) {
          ar[i] = Math.round(Math.random() * 100);
        }
        // console.log(ar);
      }

      // createlevel1(size);

      function createlevel2(size) {
        for (var i = 0; i < size; i++) {
          ar[i] = Math.round(Math.random() * 1000);
        }
        // console.log(ar);
      }
      // createlevel2(size);

      //taking input from user to select the level of addition
      level = prompt("enter the level you want to do calculation ?");
      // function startthegame(level) {
      //   if (level == 1) {
      //     createlevel1(size);
      //     ape(size);
      //     console.log(result(size));
      //   } else if (level == 2) {
      //     createlevel2(size);
      //     ape(size);
      //     console.log(result(size));
      //   }
      // }

      // calculating the result the created element
      function result(size) {
        console.log(size);
        sum = 0;
        for (let i = 0; i < size; i++) {
          sum += ar[i];
          // console.log(sum);
        }
        // console.log(sum);
        // document.querySelector("p").textContent = sum;
      }
      //   let but=document.querySelector("button")

      //for the printing the result of the addition
      $("#button").on(
        "click",

        function () {
          document.querySelector("p").textContent = sum;
        }
      );

      //program for next statment

      $("#next").on("click", function () {
        //generate a new size
        newsize = create_size();
        ar = [];

        node = document.querySelector(".num");
        while (node.hasChildNodes()) {
          node.removeChild(node.lastChild);
        }
        // .appendChild(createee(ar[a]));
        document.querySelector("p").textContent = ".....";
        if (level == 1) {
          createlevel1(newsize);
          // ape(newsize);
          // result(newsize);
        } else if (level == 2) {
          createlevel2(newsize);
          // ape(newsize);
          // result(newsize);
        }
        ape(newsize);
        result(newsize);
        //then generate new array with new values

        // actually reapeat all the process when this button is clicked
      });

      // startthegame(level);
    </script>
    <p>
      DDA
      #include<stdlib.h>
#include<stdio.h>
#include<graphics.h>
#include<math.h>
#include<iostream>
using namespace std;
int main(){

	int gd=DETECT,gm;
	initgraph(&gd, &gm, NULL);
	float x1,y1,x2,y2;
	cout<<"Enter x1 : ";
	cin>>x1;
	cout<<"Enter y1 : ";
	cin>>y1;
	cout<<"Enter x2 : ";
	cin>>x2;
	cout<<"Enter y2 : ";
	cin>>y2;
	
	float dx,dy;
	dx=x2-x1;
	dy=y2-y1;
	float m;
	m=dy/dx;
	
	float steps=0;
	if(dy>dx){
		steps=dy;
	}
	else{
		steps=dx;
	}
	
	float xinc=0,yinc=0;
	xinc=dx/steps;
	yinc=dy/steps;
	int temp;
	if(m<1){
		for(int i=0;i<steps;i++){
			x1=x1+1;
			y1=y1+yinc;
			temp=round(y1);
			putpixel(x1,temp,5);
			delay(50);
		}
	}
	
		if(m>1){
		for(int i=0;i<steps;i++){
			x1=x1+xinc;
			y1=y1+1;
			temp=round(x1);
			putpixel(temp,y1,5);
			delay(50);
		}
	}
	
		if(m==1){
		for(int i=0;i<steps;i++){
			x1=x1+1;
			y1=y1+1;
			putpixel(x1,y1,5);
			delay(50);
		}
	}
	
	getch();
	return 0;
}

      breshman line
      #include<iostream>
#include<conio.h>
#include<graphics.h>
using namespace std;

int main(){
	int x1,x2,y1,y2; //taking the input for the user coordinate of the  two points
	cout<<"x1 -> ";
	cin>>x1;
	cout<<"y1 -> ";
	cin>>y1;
	cout<<"x2 -> ";
	cin>>x2;
	cout<<"y2 -> ";
	cin>>y2;
	
	int dx,dy,p,x,y;
	
	dy=y2-y1;
	dx=x2-x1; 
	x=x1;
	y=y1;
	
	p=2*dy-dx; //what is P here?
	
	int gd=DETECT,gm;
	initgraph(&gd,&gm,NULL);
	while(x<x2){
		if(p>=0){
			putpixel(x,y,3);
			y=y+1;
			p=p+2*dy-2*dx;
			delay(50);
		}
		else{
			putpixel(x,y,3);
			p=p+2*dy;
			delay(50);
		}
		x=x+1;
	}
	
	getch();
	return 0;
}
midpoint circle
      #include<conio.h>
#include<stdlib.h>
#include<graphics.h>
#include<math.h>
#include<iostream>
using namespace std;
int main(){
	int gd=DETECT,gm;
	initgraph(&gd,&gm,NULL);
	int d,x0,y0,x,y,r;
	x=0;
	y=r;
	d=1-r;
	
	cout<<"enter the radius of circle";
	cin>>r;
	cout<<"enter the center coordinates of circle:"<<endl;
	cin>>x0>>y0;
	
	do{
	putpixel(x0+x,y0+y,4);
	putpixel(x0-x,y0+y,4);
	putpixel(x0+x,y0-y,4);
	putpixel(x0-x,y0-y,4);
	putpixel(x0+y,y0+x,4);
	putpixel(x0-y,y0+x,4);
	putpixel(x0+y,y0-x,4);
	putpixel(x0-y,y0-x,4);
		if(d<0)
		{
			x=x+1;
			y=y;
			d=d+(2*x)+2;
		}
		 else{
		 	x=x+1;
		 	y=y-1;
            d=d+2*(x-y)+1;		 
		 }
		 	
	}while(x<y);	
getch();
closegraph();


	
}

      lineclipping
      
      
      #include<graphics.h>
#include<math.h>
#include<iostream>
#include<conio.h>
using namespace std;
int LEFT=1;
int RIGHT=2;
int bottom=4;
int top=8;
int xmin,ymin,ymax,xmax;


int getcode(int x,int y)
{
	int code=0;
	if(y>ymax) code|=top;
	if(y<ymin) code|=bottom;
	if(x<xmin) code|=LEFT;
	if(x>xmax) code|=RIGHT;
	return code;
	
}

int main()
{
	int gd=DETECT , gm;
	initgraph(&gd,&gm,"");
	setcolor(WHITE);
	cout<<"enter the window size";
	cin>>xmin>>ymin>>xmax>>ymax;
	rectangle(xmin,ymin,xmax,ymax);
	int x1,y1,x2,y2;
	cout<<"enter the end point of line";
	cin>>x1>>y1>>x2>>y2;
	line(x1,y1,x2,y2);
	getch();
	int outcode1=getcode(x1,y1);
	int outcode2=getcode(x2,y2);
	cout<<outcode1;
	cout<<outcode2;
	int accept=0;
	while(true)
	{
		float m=(float)(y2-y1)/(x2-x1);
		cout<<"m="<<m<<endl;
		if(outcode1==0 && outcode2==0)
		{
			accept=1;
			cout<<accept;
			break;
		}
		else if((outcode1&outcode2)!=0)
		{
			break;
		}
		else
		{
			int temp;
			int x,y;
			if(outcode1==0)
			    temp=outcode2;
			else
			    temp=outcode1;///???
		
				if(temp&top)
				{
					x=x1+(ymax-y1)/m;
					y=ymax;
				}
				else if(temp&bottom)
				{
					x=x1+(ymin-y1)/m;
					y=ymin;
				}
				else if(temp&LEFT)
				{
					y=y1+(xmin-x1)*m;
					x=xmin;
				}
				else if(temp&RIGHT)
				{
					y=y1+(xmax-x1)*m;
					x=xmax;
				}
				if(temp==outcode1)
				{
					x1=x;
					y1=y;
					outcode1=getcode(x1,y1);
				}
				else
				{
					x2=x;
					y2=y;
					outcode2=getcode(x2,y2);
				}
				cout<<endl<<x;
				cout<<endl<<y;
				
	}
}



		cout<<"after clipping"<<endl;
		cout<<accept<<"\n";
		if(accept)


			cleardevice();
			rectangle(xmin,ymin,xmax,ymax);
			setcolor(RED);
			line(x1,y1,x2,y2);
		getch();
	    closegraph();
}
      polygonclipping
      
      #include <iostream>

#include <conio.h>

#include <graphics.h>

using namespace std;
int xl, yl, xh, yh, poly[100], n;
void left_clip() {
  int temp[100], i, j = 0, count = 0, x1, y1, x2, y2;
  for (i = 0; i < 2 * n; i += 2) {
    x1 = poly[i];
    y1 = poly[i + 1];
    x2 = poly[i + 2];
    y2 = poly[i + 3];
    if (x1 < xl && x2 < xl) {
      //both points outside. Do not store any vertices
    } else if (x1 > xl && x2 > xl) {
      //both points inside. Store second vertex
      temp[j] = x2;
      temp[j + 1] = y2;
      j += 2;
      count++;
    } else if (x1 < xl && x2 > xl) {
      //outside to inside. Store intersection n second vertex
      int x = xl;
      int y = y1 + (xl - x1) * (float)(y2 - y1) / (x2 - x1);
      temp[j] = x;
      temp[j + 1] = y;
      temp[j + 2] = x2;
      temp[j + 3] = y2;
      j += 4;
      count += 2;
    } else {
      //inside to outside. Store intersection only
      int x = xl;
      int y = y1 + (xl - x1) * (float)(y2 - y1) / (x2 - x1);
      temp[j] = x;
      temp[j + 1] = y;
      j += 2;
      count++;
    }
  }
  n = count;
  //store 1st vertex as last
  temp[j] = temp[0];
  temp[j + 1] = temp[1];

  for (i = 0; i < 2 * (n + 1); i++)
    poly[i] = temp[i];
}
void right_clip() {
  int temp[100], i, j = 0, count = 0, x1, y1, x2, y2;
  for (i = 0; i < 2 * n; i += 2) {
    x1 = poly[i];
    y1 = poly[i + 1];
    x2 = poly[i + 2];
    y2 = poly[i + 3];
    if (x1 > xh && x2 > xh) {
      //both points outside. Do not store any vertices
    } else if (x1 < xh && x2 < xh) {
      //both points inside. Store second vertex
      temp[j] = x2;
      temp[j + 1] = y2;
      j += 2;
      count++;
    } else if (x1 > xh && x2 < xh) {
      //outside to inside. Store intersection n second vertex
      int x = xh;
      int y = y1 + (xh - x1) * (float)(y2 - y1) / (x2 - x1);
      temp[j] = x;
      temp[j + 1] = y;
      temp[j + 2] = x2;
      temp[j + 3] = y2;
      j += 4;
      count += 2;
    } else {
      //inside to outside. Store intersection only
      int x = xh;
      int y = y1 + (xh - x1) * (float)(y2 - y1) / (x2 - x1);
      temp[j] = x;
      temp[j + 1] = y;
      j += 2;
      count++;
    }
  }
  n = count;
  //store 1st vertex as last
  temp[j] = temp[0];
  temp[j + 1] = temp[1];

  for (i = 0; i < 2 * (n + 1); i++)
    poly[i] = temp[i];
}
void bottom_clip() {
  int temp[100], i, j = 0, count = 0, x1, y1, x2, y2;
  for (i = 0; i < 2 * n; i += 2) {
    x1 = poly[i];
    y1 = poly[i + 1];
    x2 = poly[i + 2];
    y2 = poly[i + 3];
    if (y1 > yl && y2 > yl) {
      //both points outside. Do not store any vertices
    } else if (y1 < yl && y2 < yl) {
      //both points inside. Store second vertex
      temp[j] = x2;
      temp[j + 1] = y2;
      j += 2;
      count++;
    } else if (y1 > yl && y2 < yl) {
      //outside to inside. Store intersection n second vertex
      int x = x1 + (yl - y1) / ((float)(y2 - y1) / (x2 - x1));
      int y = yl;
      temp[j] = x;
      temp[j + 1] = y;
      temp[j + 2] = x2;
      temp[j + 3] = y2;
      j += 4;
      count += 2;
    } else {
      //inside to outside. Store intersection only
      int x = x1 + (yl - y1) / ((float)(y2 - y1) / (x2 - x1));
      int y = yl;
      temp[j] = x;
      temp[j + 1] = y;
      j += 2;
      count++;
    }
  }
  n = count;
  //store 1st vertex as last
  temp[j] = temp[0];
  temp[j + 1] = temp[1];

  for (i = 0; i < 2 * (n + 1); i++)
    poly[i] = temp[i];
}
void top_clip() {
  int temp[100], i, j = 0, count = 0, x1, y1, x2, y2;
  for (i = 0; i < 2 * n; i += 2) {
    x1 = poly[i];
    y1 = poly[i + 1];
    x2 = poly[i + 2];
    y2 = poly[i + 3];
    if (y1 < yh && y2 < yh) {
      //both points outside. Do not store any vertices
    } else if (y1 > yh && y2 > yh) {
      //both points inside. Store second vertex
      temp[j] = x2;
      temp[j + 1] = y2;
      j += 2;
      count++;
    } else if (y1 < yh && y2 > yh) {
      //outside to inside. Store intersection n second vertex
      int x = x1 + (yh - y1) / ((float)(y2 - y1) / (x2 - x1));
      int y = yh;
      temp[j] = x;
      temp[j + 1] = y;
      temp[j + 2] = x2;
      temp[j + 3] = y2;
      j += 4;
      count += 2;
    } else {
      //inside to outside. Store intersection only
      int x = x1 + (yh - y1) / ((float)(y2 - y1) / (x2 - x1));
      int y = yh;
      temp[j] = x;
      temp[j + 1] = y;
      j += 2;
      count++;
    }
  }
  n = count;
  //store 1st vertex as last
  temp[j] = temp[0];
  temp[j + 1] = temp[1];

  for (i = 0; i < 2 * (n + 1); i++)
    poly[i] = temp[i];
}
int main() {
  int gdriver = DETECT, gmode;
  initgraph( & gdriver, & gmode, NULL);
  int i;
  setcolor(BLUE);
  cout << "Enter bottom left and top right co-ordinates of window: ";
  cin >> xl >> yl >> xh >> yh;
  rectangle(xl, yl, xh, yh);
  cout << "Enter the no. of vertices: ";
  cin >> n;
  for (i = 0; i < 2 * n; i += 2) {
    cout << "Enter co-ordinates of vertex " << (i / 2 + 1) << ": ";
    cin >> poly[i] >> poly[i + 1];
  }
  //store 1st vertex as last
  poly[2 * n] = poly[0];
  poly[2 * n + 1] = poly[1];
  drawpoly(n + 1, poly);
  //getch();

  left_clip();
  right_clip();
  bottom_clip();
  top_clip();
  cout << "After clipping:";
  setcolor(WHITE);
  drawpoly(n + 1, poly);

  getch();
  closegraph();
}
      
      polygon filling
      
      
      #include<stdio.h>
#include<conio.h>
#include<graphics.h>
#include<iostream>
using namespace std;
int main(){
	int h,i,j,k,dy,dx;
	
int gd=DETECT,gm;
	int x,y,n,temp;
	int a[20][3],x1[20];
	float slope[20];
	cout<<"enter the no of edges:";
	cin>>n;
	cout<<"enter the coordinates:";
	for(i=0;i<n;i++){
		cout<<"x and y are:";
		cin>>a[i][0]>>a[i][1];
		}
		a[n][0]=a[0][0];
		a[n][1]=a[0][1];
		initgraph(&gd,&gm,NULL);
		for(i=0;i<n;i++){
			line(a[i][0],a[i][1],a[i+1][0],a[i+1][1]);
		}
		getch();
		for(i=0;i<n;i++){
			dy=a[i+1][1]-a[i][1];
			dx=a[i+1][0]-a[i][0];
			if(dy==0){
				slope[i]=1.0;
				}
				if(dx==0){
					slope[i]=0.0;
				}
		if((dy!=0)&& (dx!=0)){
			slope[i]=(float)dx/dy;
			}
			for(y=0;y<480;y++){
				k=0;
				for(i=0;i<n;i++){
					if(((a[i][1]<=y)&&(a[i+1][1]>y)) || ((a[i][1]>y) && (a[i+1][1]<=y))){
						x1[k]=(int)(a[i][0]+slope[i]*(y-a[i][1]));
						k++;
						
					}
				}
			for(j=0;j<k-1;j++)
				for(i=0;i<k-1;i++){
					if(x1[i]>x1[i+1]){
						temp=x1[i];
						x1[i]=x1[i+1];
						x1[i+1]=temp;
					}
				}
			}
			setcolor(RED);
			for(i=0;i<k;i+=2){
				line(x1[i],y,x1[i+1]+1,y);
				getch();
			}
			return 0;
			}
		
}

    </p>
  </body>
</html>
